---
title: 浅谈浮点
date: 2021-11-20 02:04:53
tags: algorithm 
---
> Q: 为什么浮点运算有误差？
> ​

> A: 因为你不可能让有限集和无限集一一映射的……


---

在看文章之前先看看万恶之源：
**题目描述**
给你一个简单的四则运算表达式，包含两个实数和一个运算符，请编程计算出结果
**输入**
表达式的格式为：s1 op s2， s1和s2是两个实数，op表示的是运算符(+,-,*,/)，也可能是其他字符。注意运算符两侧各有一个空格。
**输出**
如果运算符合法，输出表达式的值；**若运算符不合法或进行除法运算时除数是0**，**则输出"Wrong input!**"。最后结果小数点后保留两位。
**样例输入 Copy**
1.0 + 1.0
**样例输出 Copy**
**2.00**
当你开开心心写完，并且用
if(s2 == 0)
完成“**若运算符不合法或进行除法运算时除数是0则输出"Wrong input!**”的要求
一交......——啪，一巴掌拍下来一个“**答案错误**”
惊不惊喜，意不意外？
当然oj很负责任的提醒你，使用“ `fabs(b) <= 1e-10`  ”来判断非法除数
...面对莫名其妙的报错和提示，这一套连招，让你懵的猝不及防
...咳咳，所以，咱这篇文章好好来扯一扯这“浮点数”

---

## 先看现象
#### 条件判断超预期
```java
System.out.println( 1f == 0.9999999f );   // 打印：false
System.out.println( 1f == 0.99999999f );  // 打印：true    纳尼？
```
#### 数据转换超预期
```java
float f = 1.1f;
double d = (double) f;
System.out.println(f);  // 打印：1.1
System.out.println(d);  // 打印：1.100000023841858  纳尼？
```
#### 基本运算超预期
```java
System.out.println( 0.2 + 0.7 );  
// 打印：0.8999999999999999   纳尼？
```
#### 数据自增超预期
```java
float f1 = 8455263f;
for (int i = 0; i < 10; i++) {
    System.out.println(f1);
    f1++;
}
// 打印：8455263.0
// 打印：8455264.0
// 打印：8455265.0
// 打印：8455266.0
// 打印：8455267.0
// 打印：8455268.0
// 打印：8455269.0
// 打印：8455270.0
// 打印：8455271.0
// 打印：8455272.0

float f2 = 84552631f;
for (int i = 0; i < 10; i++) {
    System.out.println(f2);
    f2++;
}
//    打印：8.4552632E7   纳尼？不是 +1了吗？
//    打印：8.4552632E7   纳尼？不是 +1了吗？
//    打印：8.4552632E7   纳尼？不是 +1了吗？
//    打印：8.4552632E7   纳尼？不是 +1了吗？
//    打印：8.4552632E7   纳尼？不是 +1了吗？
//    打印：8.4552632E7   纳尼？不是 +1了吗？
//    打印：8.4552632E7   纳尼？不是 +1了吗？
//    打印：8.4552632E7   纳尼？不是 +1了吗？
//    打印：8.4552632E7   纳尼？不是 +1了吗？
//    打印：8.4552632E7   纳尼？不是 +1了吗？
```
## 原因出在哪里？
我们就以第一个典型现象为例来分析一下：
`System.out.println( 1f == 0.99999999f );`
直接用代码去比较`1`和`0.99999999`，居然打印出`true`！
这说明了什么？这说明了计算机压根**区分不出来**这两个数。这是为什么呢？
我们不妨来简单思考一下：
> 我们知道输入的这两个浮点数只是我们人类肉眼所看到的具体数值，是我们通常所理解的十进制数，但是计算机底层在计算时可不是按照十进制来计算的，学过基本计组原理的都知道，计算机底层最终都是基于像`010100100100110011011`这种`0、1`二进制来完成的。

所以为了搞懂实际情况，我们应该将这两个十进制浮点数**转化到二进制空间**来看一看。
**十进制浮点数转二进制** 怎么转、怎么计算，我想这应该属于基础计算机进制转换常识，在 **《计算机组成原理》** 类似的课上肯定学过了，咱就不在此赘述了，直接给出结果
（把它转换到`IEEE 754 Single precision 32-bit`，也就float类型对应的精度）
```java
1.0（十进制）
    ↓
00111111 10000000 00000000 00000000（二进制）
    ↓
0x3F800000（十六进制）
---------------------------------------------
0.99999999（十进制）
    ↓
00111111 10000000 00000000 00000000（二进制）
    ↓
0x3F800000（十六进制）
```
**果不其然**，这两个十进制浮点数的底层二进制表示是一毛一样的，怪不得`==`的判断结果返回`true`(
但是`1f == 0.9999999f`返回的结果是符合预期的，打印`false`，我们也把它们转换到二进制模式下看看情况：
```java
1.0（十进制）
    ↓
00111111 10000000 00000000 00000000（二进制）
    ↓
0x3F800000（十六进制）
-----------------------------------------------
0.9999999（十进制）
    ↓
00111111 01111111 11111111 11111110（二进制）
    ↓
0x3F7FFFFE（十六进制）
```
哦，很明显，它俩的二进制数字表示确实不一样，这是理所应当的结果。
那么为什么`0.99999999`的底层二进制表示竟然是：`00111111 10000000 00000000 00000000`呢？
这不明明是浮点数`1.0`的二进制表示吗？
这就要谈一下浮点数的精度问题了。
## 浮点数的精度问题！
学过 **《计算机组成原理》** 这门课的小伙伴应该都知道，浮点数在计算机中的存储方式遵循**IEEE 754 浮点数计数标准**，可以用科学计数法表示为：
 ![image.png](https://cdn.nlark.com/yuque/0/2021/png/21803058/1634052108498-bfcbaa1f-0c49-4215-a227-37d5c360192c.png#clientId=u8b3795bf-1b0c-4&from=paste&height=44&id=uc6d37584&margin=%5Bobject%20Object%5D&name=image.png&originHeight=42&originWidth=145&originalType=binary&ratio=1&size=1068&status=done&style=none&taskId=u6346e733-e6fe-4c8e-bc7d-528d8f01f31&width=152.49159240722656)
只要给出：`**符号（S）**、**阶码部分（E）**、**尾数部分（M）**` 这三个维度的信息，一个浮点数的表示就完全确定下来了，所以`float`和`double`这两种浮点数在内存中的存储结构如下所示：
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21803058/1634052159688-244db766-1e00-45e5-bab7-e106dfdb1a46.png#clientId=u8b3795bf-1b0c-4&from=paste&height=295&id=u2eb81aaf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=424&originWidth=855&originalType=binary&ratio=1&size=109910&status=done&style=none&taskId=u635967f1-8010-4199-a9b8-96e6741d560&width=595.4999694824219)
#### 1、符号部分（S）
`0-正` ` 1-负`
#### 2、阶码部分（E）（指数部分）：

- 对于`float`型浮点数，指数部分8位，考虑可正可负，因此可以表示的指数范围为`-127 ~ 128`
- 对于`double`型浮点数，指数部分11位，考虑可正可负，因此可以表示的指数范围为`-1023 ~ 1024`
#### 3、尾数部分（M）：
浮点数的精度是由尾数的位数来决定的：

- 对于`float`型浮点数，尾数部分`23`位，换算成十进制就是` 2^23=8388608`，所以十进制精度只有`6 ~ 7`位；
- 对于`double`型浮点数，尾数部分`52`位，换算成十进制就是 `2^52 = 4503599627370496`，所以十进制精度只有`15 ~ 16`位

所以对于上面的数值`0.99999999f`，很明显已经超过了`float`型浮点数据的精度范围，出问题也是在所难免的。
## 进制转换计算案例
上面说的是IEEE标准规定的内容，属于理论规约。那一个小数到底要怎么换算成二进制呢？我们得拿**实际例子**来解释。
### 先来个简单的例子
比如：**把十进制小数0.875转换成二进制，具体怎么操作？**
可以分几大步走：
**1、以小数点为界，拆分**
**2、整数部分转换**
整数转二进制我想大家应该都熟悉，使用：**除2取余法** 即可。而这里的0.875整数部分为0，无需操作。
**3、小数部分转换**
小数部分的转换不同于整数部分，采用的是 **“乘2取整法”** ，图示一下就明白了：

![image.png](https://cdn.nlark.com/yuque/0/2021/png/21803058/1634052709260-475c4ad1-dbb8-4984-921c-61206cfcf882.png#clientId=u8b3795bf-1b0c-4&from=paste&height=255&id=u43a13574&margin=%5Bobject%20Object%5D&name=image.png&originHeight=509&originWidth=863&originalType=binary&ratio=1&size=260220&status=done&style=none&taskId=ua63c4846-23b6-4c37-a848-9012485232f&width=431.5)

**4、合并结果**
整数部分 + 小数部分，最终得到二进制结果为0.111。
所以该结果按照上一节所述的**尾数 + 阶码**的计算机计数方式，则可以表示为：

![image.png](https://cdn.nlark.com/yuque/0/2021/png/21803058/1634052721645-e3c814b2-3158-42bd-8360-855ab97d553a.png#clientId=u8b3795bf-1b0c-4&from=paste&height=115&id=u72f81752&margin=%5Bobject%20Object%5D&name=image.png&originHeight=229&originWidth=615&originalType=binary&ratio=1&size=28736&status=done&style=none&taskId=u33b13787-9ba5-4628-81d4-0cf7d69dc84&width=307.5)

所以对应可得：

- **符号位**：0
- **阶码（E）部分**：若以float为例，应为 127 +（-1）= 126，因此二进制表示为：01111110
- **尾数部分（M）**：若以float为例，应为23位，因此尾部补齐后为11000000000000000000000。

因此最终的总结果为（以32位精度float表示）：
00111111011000000000000000000000
### 再来个复杂点例子
再比如：**把十进制小数6.36转换成二进制，具体怎么操作？**
但凡能用图示，我就不想写文字，所以用一张图就可以解释得明明白白：

![image.png](https://cdn.nlark.com/yuque/0/2021/png/21803058/1634052394464-bb81f88f-a43b-4d3b-8ad9-4bb95843d17d.png#clientId=u8b3795bf-1b0c-4&from=paste&id=ufbf99b5c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=578&originWidth=720&originalType=url&ratio=1&size=243586&status=done&style=none&taskId=u55c8182f-bd48-4d2f-90fc-e34e78f9784)

整数部分 + 小数部分，因此最终得到的结果二进制结果为110.01011100...。
还是按照上一节所述的**尾数 + 阶码**的计算机计数方式，则可以表示为：

![image.png](https://cdn.nlark.com/yuque/0/2021/png/21803058/1634052890028-0203b28a-27e8-4311-90ad-17b547a4cb7b.png#clientId=u8b3795bf-1b0c-4&from=paste&height=107&id=u827605bc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=214&originWidth=827&originalType=binary&ratio=1&size=33294&status=done&style=none&taskId=u0643d8ec-2f94-426d-a09a-0cbc1e82dd7&width=413.5)

所以对应可得：

- **符号位**：0
- **阶码（E）部分**：若以float为例，应为 127 +（2）= 129，因此二进制表示为：10000001
- **尾数部分（M）**：1001011100...，其实它本身无限不循环，但若以float型精度来截取23位，则可以表示为10010111000010100011111

因此最终的总结果为（以32位精度float表示）：
01000000110010111000010100011111
所以像这种无限位数的尾数情况，用计算机存储产生截取是必然的，必定会有一定的**精度损失**！所以这也从根本上解释了为什么float或者double这种类型数据使用时的风险性，因此必须要结合实际业务理性考量。
## 精度问题如何解决
所以如果涉及**商品金额**、**交易值**、**货币计算**等这种对精度要求很高的场景该怎么办呢？
### 用字符串或者数组解决多位数问题
校招刷过算法题的小伙伴们应该都知道，用字符串或者数组表示大数是一个典型的解题思路。
比如经典面试题：**编写两个任意位数大数的加法、减法、乘法等运算**。
这时候我们我们可以用字符串或者数组来表示这种大数，然后按照四则运算的规则来手动模拟出具体计算过程，中间还需要考虑各种诸如：**进位**、**借位**、**符号**等等问题的处理，确实十分复杂，本文不做赘述。

---

## 附
### 答案
```c
#include<stdio.h>
#include<math.h>
int main()
{
   double a=0.0;
   double b=0.0;
   char operation=0;

   scanf("%lf %c %lf",&a,&operation,&b);
   
   switch(operation)
   {
      case '+':
           printf("%.2lf\n",a+b);
          break;
          
      case '-':
           printf("%.2lf\n",a-b);
           break;
           
      case '*':
           printf("%.2lf\n",a*b);
           break;
        
      case '/':
           if(fabs(b) <= 1e-10)
             printf("Wrong input!");
           else
             printf("%.2lf\n",a/b);
           break;
      
      default:
          printf("Wrong input!");
          break;          
    }
    return 0;
}
```
### 以前的解释
> 如果你确实就是想判断 y 是不是 0，那么是可以直接写 y != 0 的。如果这个 y 有别的作用，比如作为除数参与其他运算，由于 C 语言不支持无限精度计算，一个极小的非零数和零一样可能导致异常的结果，因此需要排除这种情况。（知乎）

>  用浮点方式表示实数时，实数的小数部分在十进制转二进制时会出现无限循环，只能截断，所以就不准确了，是对这个实数的近似。  
> ​

> 那么，当这个数的精度无限大后，它对于编译器来说，就等价为"0"了


