---
title: bit_operation
date: 2021-11-20 01:51:38
tags: algorithm
---
# 位运算
## &（and,和 运算,二元）
and运算通常用于二进制的取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数（Eg：快速奇偶判断）
```c
#include<stdio.h>
int main()
{
    int n;
    scanf("%d",&n);
    n&1?printf("odd"):printf("even");
}
```
其原理为“相同位的两个数字都为1，则为1(True)；若有一个不为1，则为0(False)”
举个栗子：
**20：10100        20:10100**
**01：00001        04:00100**
**------------        -----------**
**re：00000         re:00100**
**10=  0               10= 4**
##  |（or,或 运算，二元）
（相同位只要一个为1即为1）
or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。
在这里你会发现一个有意思的东西：在某些情况(其实就是**不进位**的情况下)下a+b 和 a|b是等价的
**153:10011001**
**102:01100110**
**|   =255**
如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。
```javascript
var a = 103;
var c = (a | 1) - 1;//注意优先级
console.log(c);
```
**控制台输出：102**
**103：1100111**
**| 1  :  1100111**
**-1   :   1100110**
## xor，异或 运算 ^（二元）
按位异或运算, 对等长二进制模式按位或二进制数的每一位执行逻辑按位异或操作，操作的结果是如果某位不同则该位为1, 否则该位为0.（相同位不同则为1，相同则为0）
**00101**
**11100**
**-------**
**11001**
> xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a xor b) xor b = a。xor运算可以用于简单的加密，比如我想对我MM说1314520，但怕别人知道，于是双方约定拿我的生日19880516作为密钥。1314520 xor 19880516 = 20665500，我就把20665500告诉MM。MM再次计算20665500 xor 19880516的值，得到1314520。

**在不进位的情况下，xor,or的运行结果相同~**
```c
var a = 2;
var b = 153 ^ 102;
console.log(b);
//输出225
```
## not，非 运算 ~（一元）
not运算的定义是把内存中的0和1全部取反。
使用not运算时要格外小心，你需要注意整数类型有没有符号。如果not的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用00到$FFFF依次表示的。
下面程序返回65535-100=65435:
```c
#include<stdio.h>
int main()
{
    unsigned short a=100;
    a=~a;
    printf("%d\n",a);
    return 0;
}
```
**~的使用技巧：**
记得 **!=EOF**吗，关于代码"`if(scanf("%d",n)!=EOF)`",它可以写成"`if(~scanf("%d",n))`"
因为scanf如果没有输入值就是返回**_-1_**，对于-1取反，则为0,**0 ==  false**
这里注意，布尔类型和数字类型的非运算符号不一样，布尔类型是!，数字类型是~。
## shr，右移 运算 >>（二元）
a shr b表示二进制右移b位（去掉末b位）
举个栗子：
运行这段代码：
```javascript
var b = 985;
b >>= 1;
console.log(b);
```
**控制台会输出：492，原理如下**
**985：1111011001**
**>>1**
**492： 0111101100**
**可以看到，985的二进制想右位移1位，高位用0补齐了；**
_ **&与>>的运用**_
可用来取**整数n**的**二进制数**的第**k**位数
**_n>>k&1_**
```javascript
var n = 211;
var w = n >> 4 & 1;
console.log(w);
```
**控制台会输出：1，即是211二进制表示的第4位数**
**原理解析：**
**211： 11010011**
**>>4    00001101**
**&1      00000001**
**re10 ：1**
## shl，左移 运算 <<（二元）
同理，我们的<<运算符则是向左移动，通常可以用来快速进行2的幂运算
这里直接用2的幂运算举例子
```javascript
var a = 2<<4;
console.log(a);
```
**控制台会输出：32，也就是2的4+1次幂，为什么是4+1？**
**原理同>>,下面具体化一下：**
**02：_0000_10**
**<<4**
**32：100000**
## 无符号右移（二元）
**无符号右移在C中并不存在，在C中对无符号数进行右移便是无符号右移！**
**（在其他支持语言中大多为>>>）**
无符号右移是将二进制数所有位向右移动指定位数，与右移不同，无符号右移空位永远补0。
例如：`0b10011 >>> 2 = 0b00100[11]`（括号中的数是被裁掉的数）。
​

# 
**​**

# 
